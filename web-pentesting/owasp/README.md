# OWASP

## **IDOR (Insecure Direct Object Reference)**

Eine IDOR-Schwachstelle tritt auf, wenn eine Anwendung es ermöglicht, durch Manipulation von URL-Parametern unberechtigt auf Daten anderer Benutzer zuzugreifen, ohne dass die Berechtigungen überprüft werden.

**Beispiel:**

1. **URL:** `.../account?id=111111` (zeigt Konto des angemeldeten Benutzers)
2. **Manipulation:** Ändern der ID auf `id=222222`
3. **Ergebnis:** Zugriff auf fremdes Konto, wenn keine Berechtigungsprüfung erfolgt

***

## **Cryptographic Failures**

Ein kryptografischer Fehler bezieht sich auf jede Schwachstelle, die durch den Missbrauch oder das Fehlen kryptografischer Algorithmen zum Schutz sensibler Informationen entsteht. Webanwendungen benötigen Kryptografie, um die Vertraulichkeit ihrer Benutzer auf verschiedenen Ebenen zu gewährleisten.

**Beispiel: Sichere E-Mail-Anwendung**

* **Datenübertragung (Data in Transit)**: Beim Zugriff auf dein E-Mail-Konto über den Browser möchtest du sicherstellen, dass die Kommunikation zwischen dir und dem Server verschlüsselt ist. Dadurch wird verhindert, dass ein Lauscher, der deine Netzwerkanfragen abfängt, den Inhalt deiner E-Mails entschlüsseln kann.
* **Datenspeicherung (Data at Rest)**: Da deine E-Mails auf einem Server deines Anbieters gespeichert werden, wäre es wünschenswert, dass selbst der E-Mail-Anbieter diese nicht lesen kann. Dies wird durch die Verschlüsselung der E-Mails auf dem Server erreicht.

**Folgen kryptografischer Fehler**

Kryptografische Fehler können dazu führen, dass Webanwendungen versehentlich sensible Daten preisgeben. Dies können personenbezogene Daten wie Namen, Geburtsdaten und Finanzinformationen sein, aber auch technische Informationen wie Benutzernamen und Passwörter.

**Angriffe durch kryptografische Fehler**

* **Man-in-the-Middle-Angriffe (MITM)**: Ein Angreifer zwingt den Benutzer, sich über ein von ihm kontrolliertes Gerät zu verbinden. Der Angreifer kann dann schwache Verschlüsselungstechniken ausnutzen, um an die abgefangenen Informationen zu gelangen, falls diese überhaupt verschlüsselt sind.
* **Direkte Serverzugriffe**: In manchen Fällen sind die sensiblen Daten direkt auf dem Webserver zu finden, ohne dass umfangreiche Netzwerkspezialkenntnisse erforderlich sind.

***

## Datenbanken und Sicherheitsrisiken

Datenbanken sind die gängigste Methode, um große Datenmengen für Webanwendungen zu speichern. Sie ermöglichen mehreren Benutzern gleichzeitig den Zugriff auf die Website und folgen oft der **SQL-Syntax**.

### **Arten von Datenbanken**

* **Datenbankserver**: Werden häufig auf dedizierten Servern mit Diensten wie MySQL oder MariaDB betrieben.
* **Flat-File-Datenbanken**: Einfachere, als einzelne Dateien gespeicherte Datenbanken, oft in kleineren Webanwendungen genutzt.

### **Sicherheitsproblem bei Flat-File-Datenbanken**

Ein großes Problem tritt auf, wenn eine Flat-File-Datenbank **unterhalb des Root-Verzeichnisses** der Website gespeichert wird, also in einem Bereich, der für den Benutzer zugänglich ist. In diesem Fall könnte ein Angreifer die Datenbankdatei herunterladen und lokal analysieren, wodurch potenziell sensible Daten offengelegt werden.

### Beispiel: Zugriff auf eine SQLite-Datenbank

Der einfachste und am häufigsten verwendete Typ einer Flat-File-Datenbank ist eine **SQLite-Datenbank**. Diese kann in den meisten Programmiersprachen verwendet werden und hat einen eigenen Client zur Abfrage über die Kommandozeile, der oft auf Linux-Systemen vorinstalliert ist.

**Vorgehen bei einem erfolgreichen Download einer SQLite-Datenbank**

1.  **Datei überprüfen**:

    ```bash
    user@linux$ file example.db 
    example.db: SQLite 3.x database, last written using SQLite version 3039002
    ```

    Die Ausgabe zeigt, dass sich eine SQLite-Datenbank im aktuellen Verzeichnis befindet.
2.  **Zugriff auf die Datenbank**:

    ```bash
    user@linux$ sqlite3 example.db
    SQLite version 3.39.2 2022-07-21 15:24:47
    Enter ".help" for usage hints.
    sqlite>
    ```
3.  **Tabellen anzeigen**:

    ```bash
    sqlite> .tables
    customers
    ```
4.  **Tabellenstruktur analysieren**:

    ```bash
    sqlite> PRAGMA table_info(customers);
    0|custID|INT|1||1
    1|custName|TEXT|1||0
    2|creditCard|TEXT|0||0
    3|password|TEXT|1||0
    ```
5.  **Daten aus der Tabelle abrufen**:

    ```bash
    sqlite> SELECT * FROM customers;
    0|Joy Paulson|4916 9012 2231 7905|5f4dcc3b5aa765d61d8327deb882cf99
    1|John Walters|4671 5376 3366 8125|fef08f333cc53594c8097eba1f35726a
    ```

In diesem Fall sehen wir, dass sensible Informationen wie Kreditkartennummern und Passwort-Hashes in der Datenbank gespeichert sind. Diese Daten können von einem Angreifer ausgelesen und weiterverwendet werden, z. B. durch **Passwort-Cracking** der Hashes, um Zugriff auf Konten zu erhalten.

#### Next step wäre Hash Cracking

## Injection-Schwachstellen

Injection-Schwachstellen sind heute in vielen Anwendungen verbreitet. Sie entstehen, wenn benutzerkontrollierte Eingaben von der Anwendung als Befehle oder Parameter interpretiert werden. Die Art der Angriffsmöglichkeit hängt von den verwendeten Technologien und deren Interpretation der Eingaben ab.

### **Häufige Arten von Injection-Angriffen:**

* **SQL Injection**: Hierbei wird benutzerkontrollierte Eingabe in SQL-Abfragen eingeschleust. Ein Angreifer kann dadurch SQL-Befehle ausführen, um Datenbanken zu manipulieren.
* **Command Injection**: Dabei wird Benutzereingabe in Systembefehle eingebunden. Ein Angreifer kann so beliebige Systembefehle auf den Servern der Anwendung ausführen und möglicherweise Zugriff auf die Systeme der Nutzer erlangen.

### Schutzmaßnahmen gegen Injection-Angriffe

Um Injection-Angriffe zu verhindern, sollte benutzerkontrollierte Eingabe nicht als Befehle oder Abfragen interpretiert werden:

* **Allow-List-Verfahren**: Die Eingabe wird mit einer Liste sicherer Eingaben oder Zeichen verglichen. Nur sichere Eingaben werden akzeptiert; alle anderen führen zu einem Fehler.
* **Input-Filterung**: Gefährliche Zeichen werden vor der Verarbeitung entfernt.
