# Password Hash Cracking / Bruteforce

## **Zielübersicht**

Hashing und Verschlüsselung sind fundamentale, aber unterschiedliche Konzepte in der IT-Sicherheit. Verschlüsselung verschlüsselt Daten in eine Form, die mit einem Schlüssel wieder entschlüsselt werden kann. Hashing hingegen transformiert Daten in einen festen Wert, der nicht umkehrbar ist.

## **Vergleich von Hashing und Verschlüsselung**

*   **Hashing**: Ein Einwegverfahren, das beliebige Eingaben in einen festen Hashwert transformiert. Der Hashwert kann nur durch den ursprünglichen Input reproduziert werden, nicht jedoch umgekehrt.

    Beispiel:

    ```bash
    echo -n "Password123" | md5sum
    42f749ade7f9e195bf475f37a44cafcb  -
    ```

    Der String "Password123" wird gehasht, und das Ergebnis ist der MD5-Hash. Dieser Hash kann nicht zurückgerechnet werden.
*   **Verschlüsselung**: Ein Verfahren, um Daten mit einem Schlüssel in nicht lesbare Form zu bringen, die mit dem richtigen Schlüssel wieder entschlüsselt werden kann.

    Beispiel für die Entschlüsselung von AES-256-verschlüsselten Strings:

    ```bash
    echo "U2FsdGVkX1/EOnUt57TCW4Rh0EdNnWX+lDatuQv2xEXXeAeowW0XG/EXJUe9aSUz" | openssl enc -base64 -d -aes-256-cbc -pass pass:asdf
    foobarfoobarfoobar
    ```

    Der verschlüsselte Text wird hier mit dem Schlüssel "asdf" entschlüsselt.

## **Warum ist Hashing nicht entschlüsselbar?**

Hashing ist eine **Einwegfunktion**, bei der es keinen Schlüssel gibt, um den Hashwert zurück in den Originaltext zu konvertieren. Alleine die Tatsache, dass Informationen verloren gehen und der Hashwert eine feste Länge hat, macht eine Umkehrung unmöglich. Stattdessen wird der erzeugte Hashwert nur verwendet, um die Integrität oder Gleichheit von Daten zu überprüfen, z. B. um Passwörter zu validieren. Verschlüsselung hingegen ist immer reversibel, da sie auf einem Schlüssel basiert.

## **Iteration**

**Iteration** bedeutet, dass der Hash-Prozess viele Male wiederholt wird, wodurch die Berechnung des Hashwertes mehr Zeit in Anspruch nimmt und **brute-force-Angriffe** stark erschwert werden. Dies wird von modernen Hash-Algorithmen wie **bcrypt**, **scrypt** oder **argon2** verwendet. Bei diesen Algorithmen wird der Hashwert mehrfach neu gehasht – tausende Male, um die Sicherheit zu erhöhen.

Beispielsweise verwendet **sha512crypt** standardmäßig 5000 Iterationen, was die Zeit, die ein Angreifer benötigt, um den Hash zu brechen, erheblich erhöht.

## **Salting**

**Salting** bedeutet, dass eine zufällige Zeichenfolge (Salt) vor dem Hashen zum Passwort hinzugefügt wird, um sicherzustellen, dass identische Passwörter unterschiedliche Hashes erzeugen. Das macht Rainbow-Tables unbrauchbar.

Beispiel eines salted SHA1-Hashes:

```plaintext
b353977827f67a4ae0318f3a9447fae1c13d9d90:b8d18ca
|______________________________________|||_____|
                  Hash                   | Salt
```

Der Salt wird hier an das Passwort "password" angehängt, bevor der Hash generiert wird.

## **Effect of Hash Type on Cracking Speed**

Die Wahl des Hash-Algorithmus hat einen erheblichen Einfluss auf die Schwierigkeit, den Hash zu knacken. Je nach Hash-Verfahren variiert die erforderliche Zeit, um Passwörter zu knacken, stark. Einfachere Algorithmen wie **MD5** oder **SHA-1** sind schnell zu berechnen und damit anfälliger für brute-force-Angriffe, während neuere Algorithmen wie **bcrypt**, **scrypt** oder **argon2** durch Salts und Iterationen die Rechenzeit drastisch erhöhen.

Ein Vergleich:

* **MD5**: Sehr schnell, knackbar mit moderner Hardware innerhalb von Sekunden.
* **bcrypt** mit hohem Kostenfaktor: Wesentlich langsamer, die Rechenzeit kann Sekunden für nur einen einzigen Hash betragen, was brute-force-Angriffe praktisch unmöglich macht.

Beispiel: Unsere GPU (z. B. eine GTX 980) knackt **SHA-1** Hashes mit einer Geschwindigkeit von **3,5 Milliarden Kandidaten pro Sekunde**. Wird ein Salt verwendet und sind die Hashes mehrfach iteriert, reduziert sich die Geschwindigkeit erheblich.

## **Identifying Hash Types**

Bevor ein Hash geknackt werden kann, muss der Angreifer den verwendeten Hash-Algorithmus erkennen. Dies erfolgt durch die Analyse der Länge und des Formats des Hashes.

Ein praktisches Tool, um Hashtypen zu identifizieren, ist **hash-identifier**, welches in **Kali Linux** enthalten ist. Es kann verwendet werden, um unbekannte Hashes zu analysieren und zu erkennen:

```bash
hash-identifier
Identify the following hash: 42f749ade7f9e195bf475f37a44cafcb
Possible hash types:
  [MD5]
  [NTLM]
```

Die Länge und das Format lassen darauf schließen, dass es sich um einen MD5-Hash handelt.

## **Kollisionen und ihre Probleme**

Eine **Kollision** tritt auf, wenn zwei unterschiedliche Eingaben denselben Hashwert erzeugen. Dies stellt ein Sicherheitsproblem dar, da ein Angreifer möglicherweise einen alternativen Input finden kann, der denselben Hash ergibt wie das eigentliche Passwort.

Ein bekanntes Beispiel ist das unsichere **Hashverfahren von Microsoft Office**, welches leicht Kollisionen erzeugte und so das Knacken von Passwortschutz ermöglicht hat. Solche Schwächen führen dazu, dass Algorithmen als gebrochen betrachtet werden und durch sicherere Methoden ersetzt werden müssen.

## **Sicherheitshinweise für Hashing und Verschlüsselung**

* Verwenden Sie starke, moderne Hashing-Algorithmen wie **bcrypt**, **scrypt** oder **argon2**, die für ihre Sicherheitsmechanismen bekannt sind.
* Verwenden Sie einzigartige, zufällige **Salts** für jedes Passwort, um Angriffe mit Rainbow-Tables zu verhindern.
* Verwenden Sie **Iteration**, um die Berechnung der Hashes zeitintensiver zu gestalten und brute-force-Angriffe zu erschweren.
* Bei der Verschlüsselung sollte ein ausreichend langer und sicherer Schlüssel verwendet werden.

Durch die Wahl eines geeigneten Algorithmus, den Einsatz von Salts und Iterationen können Sie die Sicherheit Ihrer Systeme drastisch erhöhen und potenzielle Angriffe abwehren.
